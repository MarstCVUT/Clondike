diff -Nupr A/Makefile B/Makefile
--- A/Makefile	2010-03-15 17:09:39.000000000 +0100
+++ B/Makefile	2011-05-22 10:36:45.000000000 +0200
@@ -475,7 +475,7 @@ scripts: scripts_basic include/config/au
 
 # Objects we will link into vmlinux / subdirs we need to visit
 init-y		:= init/
-drivers-y	:= drivers/ sound/ firmware/
+drivers-y	:= drivers/ sound/ firmware/ clondike/
 net-y		:= net/
 libs-y		:= lib/
 core-y		:= usr/
diff -Nupr A/arch/um/Kconfig.rest B/arch/um/Kconfig.rest
--- A/arch/um/Kconfig.rest	2010-03-15 17:09:39.000000000 +0100
+++ B/arch/um/Kconfig.rest	2011-05-22 10:36:45.000000000 +0200
@@ -28,6 +28,8 @@ source "drivers/scsi/Kconfig"
 
 source "drivers/md/Kconfig"
 
+source "clondike/Kconfig"
+
 if BROKEN
 	source "drivers/mtd/Kconfig"
 endif
diff -Nupr A/arch/um/include/shared/syscall.h B/arch/um/include/shared/syscall.h
--- A/arch/um/include/shared/syscall.h	2010-03-15 17:09:39.000000000 +0100
+++ B/arch/um/include/shared/syscall.h	2011-05-22 10:36:45.000000000 +0200
@@ -8,5 +8,6 @@
 
 extern int record_syscall_start(int syscall);
 extern void record_syscall_end(int index, long result);
+int clondike_kernel_execve(const char *filename, char *const argv[], char *const envp[]);
 
 #endif
diff -Nupr A/arch/um/kernel/skas/clone.c B/arch/um/kernel/skas/clone.c
--- A/arch/um/kernel/skas/clone.c	2010-03-15 17:09:39.000000000 +0100
+++ B/arch/um/kernel/skas/clone.c	2011-05-22 10:36:45.000000000 +0200
@@ -6,6 +6,7 @@
 #include <signal.h>
 #include <sched.h>
 #include <asm/unistd.h>
+#include <asm/page.h>
 #include <sys/time.h>
 #include "as-layout.h"
 #include "kern_constants.h"
diff -Nupr A/arch/um/kernel/skas/syscall.c B/arch/um/kernel/skas/syscall.c
--- A/arch/um/kernel/skas/syscall.c	2010-03-15 17:09:39.000000000 +0100
+++ B/arch/um/kernel/skas/syscall.c	2011-05-22 10:36:45.000000000 +0200
@@ -9,6 +9,10 @@
 #include "sysdep/ptrace.h"
 #include "sysdep/syscalls.h"
 
+#include "linux/module.h"
+#include "longjmp.h"
+#include <clondike/tcmi/tcmi_dbg.h>
+
 extern int syscall_table_size;
 #define NR_syscalls (syscall_table_size / sizeof(void *))
 
@@ -38,3 +42,38 @@ void handle_syscall(struct uml_pt_regs *
 
 	syscall_trace(r, 1);
 }
+
+int clondike_kernel_execve(const char *filename, char *const argv[], char *const envp[])
+{
+        int ret = 0;
+        jmp_buf buf;
+        int n;
+
+        TCMI_ON_DEBUG
+        {
+         printk("clondike_kernel_execve: %s %p\n",filename,current->thread.exec_buf);
+        }
+
+        if(current->thread.exec_buf)
+        {
+                return kernel_execve(filename,argv,envp);
+        }
+
+        current->thread.exec_buf = &buf;
+        n = UML_SETJMP(&buf);
+        TCMI_ON_DEBUG
+        {
+         printk("clondike_kernel_execve - setjmp %d\n",n);
+        }
+        if(n == 0)kernel_execve(filename,argv,envp);
+        interrupt_end();
+        userspace(&current->thread.regs.regs);
+        TCMI_ON_DEBUG
+        {
+         printk("clondike_kernel_execve: %s ret: %d\n",filename,ret);
+        }
+        return ret;
+
+}
+
+EXPORT_SYMBOL(clondike_kernel_execve);
diff -Nupr A/arch/x86/Kconfig B/arch/x86/Kconfig
--- A/arch/x86/Kconfig	2010-03-15 17:09:39.000000000 +0100
+++ B/arch/x86/Kconfig	2011-05-22 10:36:45.000000000 +0200
@@ -2090,3 +2090,5 @@ source "crypto/Kconfig"
 source "arch/x86/kvm/Kconfig"
 
 source "lib/Kconfig"
+
+source "clondike/Kconfig"
diff -Nupr A/arch/x86/kernel/entry_64.S B/arch/x86/kernel/entry_64.S
--- A/arch/x86/kernel/entry_64.S	2010-03-15 17:09:39.000000000 +0100
+++ B/arch/x86/kernel/entry_64.S	2011-05-22 10:36:45.000000000 +0200
@@ -1212,6 +1212,35 @@ ENTRY(kernel_execve)
 	CFI_ENDPROC
 END(kernel_execve)
 
+/* 
+ In clondike version of we set orig rax value into the register, instead of rax value of pt_regs. 
+ This way, we are able to restore non-zero values, as rax must be zero after successful sys_execve.. 
+ */
+ENTRY(clondike_execve)
+	CFI_STARTPROC
+	FAKE_STACK_FRAME $0
+	SAVE_ALL	
+	movq %rsp,%rcx
+	call sys_execve	
+	movq %rax, RAX(%rsp)
+	testq %rax,%rax
+	jnz failedexec
+	/* After we've checked return value, we set rax to value of orig rax */
+	movq ORIG_RAX(%rsp), %rax
+	/* And in addition we need to set eax to RAX pt regs to correctly survive args restore */
+	movq %rax, RAX(%rsp)
+
+	RESTORE_REST	
+	jmp int_ret_from_sys_call
+failedexec:
+	RESTORE_REST	
+	RESTORE_ARGS
+	UNFAKE_STACK_FRAME
+	ret
+	CFI_ENDPROC
+ENDPROC(clondike_execve)
+
+
 /* Call softirq on interrupt stack. Interrupts are off. */
 ENTRY(call_softirq)
 	CFI_STARTPROC
diff -Nupr A/arch/x86/kernel/process_64.c B/arch/x86/kernel/process_64.c
--- A/arch/x86/kernel/process_64.c	2010-03-15 17:09:39.000000000 +0100
+++ B/arch/x86/kernel/process_64.c	2011-05-22 10:36:45.000000000 +0200
@@ -365,6 +365,8 @@ start_thread(struct pt_regs *regs, unsig
 			    __USER_CS, __USER_DS, 0);
 }
 
+EXPORT_SYMBOL_GPL(start_thread);
+
 #ifdef CONFIG_IA32_EMULATION
 void start_thread_ia32(struct pt_regs *regs, u32 new_ip, u32 new_sp)
 {
diff -Nupr A/arch/x86/kernel/x8664_ksyms_64.c B/arch/x86/kernel/x8664_ksyms_64.c
--- A/arch/x86/kernel/x8664_ksyms_64.c	2010-03-15 17:09:39.000000000 +0100
+++ B/arch/x86/kernel/x8664_ksyms_64.c	2011-05-22 10:36:45.000000000 +0200
@@ -12,6 +12,8 @@
 #include <asm/desc.h>
 #include <asm/ftrace.h>
 
+#include <asm/desc.h>
+
 #ifdef CONFIG_FUNCTION_TRACER
 /* mcount is defined in assembly */
 EXPORT_SYMBOL(mcount);
@@ -36,6 +38,13 @@ EXPORT_SYMBOL(clear_page);
 
 EXPORT_SYMBOL(csum_partial);
 
+
+int kernel_execve(const char *filename, char *const argv[], char *const envp[]);
+EXPORT_SYMBOL(kernel_execve);
+int clondike_execve(const char *filename, char *const argv[], char *const envp[]);
+EXPORT_SYMBOL(clondike_execve);
+
+
 /*
  * Export string functions. We normally rely on gcc builtin for most of these,
  * but gcc sometimes decides not to inline them.
diff -Nupr A/arch/x86/mm/fault.c B/arch/x86/mm/fault.c
--- A/arch/x86/mm/fault.c	2010-03-15 17:09:39.000000000 +0100
+++ B/arch/x86/mm/fault.c	2011-05-22 10:36:45.000000000 +0200
@@ -12,6 +12,8 @@
 #include <linux/mmiotrace.h>		/* kmmio_handler, ...		*/
 #include <linux/perf_event.h>		/* perf_sw_event		*/
 
+#include <clondike/tcmi/tcmi_dbg.h>
+
 #include <asm/traps.h>			/* dotraplinkage, ...		*/
 #include <asm/pgalloc.h>		/* pgd_*(), ...			*/
 #include <asm/kmemcheck.h>		/* kmemcheck_*(), ...		*/
@@ -761,6 +763,12 @@ __bad_area(struct pt_regs *regs, unsigne
 	 */
 	up_read(&mm->mmap_sem);
 
+	TCMI_ON_DEBUG {
+		printk(KERN_DEBUG "Sending SIGSEGV - bad area at %lx, PID: %d\n", address, current->pid);
+		// dump_stack();
+	}
+
+
 	__bad_area_nosemaphore(regs, error_code, address, si_code);
 }
 
@@ -959,6 +967,11 @@ do_page_fault(struct pt_regs *regs, unsi
 	/* Get the faulting address: */
 	address = read_cr2();
 
+	/* TCMI testing */
+	TCMI_ON_DEBUG {
+		printk(KERN_INFO "Begin page fault at %lx\n", address);
+	}
+
 	/*
 	 * Detect and handle instructions that would cause a page fault for
 	 * both a tracked kernel page and a userspace page.
@@ -1008,6 +1021,12 @@ do_page_fault(struct pt_regs *regs, unsi
 		return;
 	}
 
+ 
+	/* TCMI testing */
+	TCMI_ON_DEBUG {
+		printk(KERN_INFO "Not in kernel space - page fault at %lx \n", address);
+	}
+
 	/* kprobes don't want to hook the spurious faults: */
 	if (unlikely(notify_page_fault(regs)))
 		return;
@@ -1036,6 +1055,11 @@ do_page_fault(struct pt_regs *regs, unsi
 	 * in an atomic region then we must not take the fault:
 	 */
 	if (unlikely(in_atomic() || !mm)) {
+	  	/* TCMI testing */
+		TCMI_ON_DEBUG {
+			printk(KERN_INFO "going to no sem in atomic=%d, mm=%p, page fault at %lx\n", in_atomic(), mm, address);
+		}
+	  
 		bad_area_nosemaphore(regs, error_code, address);
 		return;
 	}
@@ -1074,12 +1098,27 @@ do_page_fault(struct pt_regs *regs, unsi
 
 	vma = find_vma(mm, address);
 	if (unlikely(!vma)) {
+	  	TCMI_ON_DEBUG {
+			printk(KERN_DEBUG "Can't find VMA for address %lx\n", address);
+		}
+
 		bad_area(regs, error_code, address);
 		return;
 	}
-	if (likely(vma->vm_start <= address))
+
+	if (likely(vma->vm_start <= address)) {
+		/* TCMI testing */
+		TCMI_ON_DEBUG {
+			printk(KERN_DEBUG "Address (%lx) in vm area, good area\n", address);
+		}
 		goto good_area;
+	}
 	if (unlikely(!(vma->vm_flags & VM_GROWSDOWN))) {
+		/* TCMI testing */
+		TCMI_ON_DEBUG {
+			printk(KERN_DEBUG "Address (%lx) not in vm area, and area (start %lx) not VM_GROWSDOWN\n", 
+			       address, vma->vm_start);
+		}	  
 		bad_area(regs, error_code, address);
 		return;
 	}
@@ -1091,11 +1130,19 @@ do_page_fault(struct pt_regs *regs, unsi
 		 * 32 pointers and then decrements %sp by 65535.)
 		 */
 		if (unlikely(address + 65536 + 32 * sizeof(unsigned long) < regs->sp)) {
+			/* TCMI testing */
+			TCMI_ON_DEBUG {
+				printk(KERN_DEBUG "User space stack expansion at %lx\n", address);
+			}		  
 			bad_area(regs, error_code, address);
 			return;
 		}
 	}
 	if (unlikely(expand_stack(vma, address))) {
+  		/* TCMI testing */
+		TCMI_ON_DEBUG {
+			printk(KERN_DEBUG "Failed to expand stack at %lx\n", address);
+		}
 		bad_area(regs, error_code, address);
 		return;
 	}
@@ -1107,6 +1154,11 @@ do_page_fault(struct pt_regs *regs, unsi
 good_area:
 	write = error_code & PF_WRITE;
 
+	/* TCMI testing */
+	TCMI_ON_DEBUG {
+		printk(KERN_DEBUG "Good area at %lx, error code was %lx\n", address, error_code);
+	}	
+	
 	if (unlikely(access_error(error_code, write, vma))) {
 		bad_area_access_error(regs, error_code, address);
 		return;
diff -Nupr A/arch/x86/vdso/vdso32-setup.c B/arch/x86/vdso/vdso32-setup.c
--- A/arch/x86/vdso/vdso32-setup.c	2010-03-15 17:09:39.000000000 +0100
+++ B/arch/x86/vdso/vdso32-setup.c	2011-05-22 10:36:45.000000000 +0200
@@ -372,6 +372,8 @@ int arch_setup_additional_pages(struct l
 	return ret;
 }
 
+EXPORT_SYMBOL(arch_setup_additional_pages);
+
 #ifdef CONFIG_X86_64
 
 __initcall(sysenter_setup);
diff -Nupr A/clondike/Kconfig B/clondike/Kconfig
--- A/clondike/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ B/clondike/Kconfig	2011-05-22 10:40:32.000000000 +0200
@@ -0,0 +1,56 @@
+#
+# Clondike
+#
+
+menu "Clondike"
+
+config TCMI
+	tristate "Enable TCMI"
+	select TCMI_HOOKS
+	help
+	  Clondike is a clustering project started at FEE CTU Prague.
+	  To read more see project website at http://clondike.felk.cvut.cz
+	  This option enables Task Checkpointing and Migration Infrastructure(TCMI) 
+	  support in the kernel. 
+	
+
+	  If unsure, say N.
+
+config TCMI_HOOKS
+	bool "TCMI hooks"
+	depends on TCMI
+	help
+	  This option enables kernel hooks used by Task Checkpointing
+	  and Migration Infrastructure(TCMI) to intercept various system
+	  calls and install migration mode handler. 
+
+
+config TCMI_CCN
+	bool "Enable TCMI CCN support"
+	depends on TCMI
+	help
+	  Enables Cluster Core Node (CCN) support in TCMI framework.
+
+
+	  If unsure, say N.
+
+config TCMI_PEN
+	bool "Enable TCMI PEN support"
+	depends on TCMI
+	help
+	  Enables Process Execution Node (PEN) support in TCMI framework.
+
+
+	  If unsure, say N.
+
+config TCMI_DEBUG
+	bool "Enable TCMI debug messages"
+	depends on TCMI
+	help
+	  Enables TCMI debug messages
+	
+	
+	  If unsure, say N.
+
+endmenu
+
diff -Nupr A/clondike/Kconfig~ B/clondike/Kconfig~
--- A/clondike/Kconfig~	1970-01-01 01:00:00.000000000 +0100
+++ B/clondike/Kconfig~	2011-05-22 10:36:45.000000000 +0200
@@ -0,0 +1,46 @@
+#
+# Clondike
+#
+
+menu "Clondike"
+
+config TCMI
+	tristate "Enable TCMI"
+	select TCMI_HOOKS
+	help
+	  Clondike is a clustering project started at FEE CTU Prague.
+	  To read more see project website at http://clondike.felk.cvut.cz
+	  This option enables Task Checkpointing and Migration Infrastructure(TCMI) 
+	  support in the kernel. 
+	
+
+	  If unsure, say N.
+
+config TCMI_HOOKS
+	bool "TCMI hooks"
+	depends on TCMI
+	help
+	  This option enables kernel hooks used by Task Checkpointing
+	  and Migration Infrastructure(TCMI) to intercept various system
+	  calls and install migration mode handler. 
+
+
+config TCMI_CCN
+	bool "Enable TCMI CCN support"
+	depends on TCMI
+	help
+	  Enables Cluster Core Node (CCN) support in TCMI framework.
+
+
+	  If unsure, say N.
+
+config TCMI_PEN
+	bool "Enable TCMI PEN support"
+	depends on TCMI
+	help
+	  Enables Process Execution Node (PEN) support in TCMI framework.
+
+
+	  If unsure, say N.
+endmenu
+
diff -Nupr A/clondike/Makefile B/clondike/Makefile
--- A/clondike/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ B/clondike/Makefile	2011-05-22 10:54:44.000000000 +0200
@@ -0,0 +1,7 @@
+# Builds the Clondike system
+#
+#
+obj-y += tcmi/
+ifeq ($(CONFIG_TCMI),y)
+	obj-y += src/
+endif
diff -Nupr A/clondike/Makefile~ B/clondike/Makefile~
--- A/clondike/Makefile~	1970-01-01 01:00:00.000000000 +0100
+++ B/clondike/Makefile~	2011-05-22 10:36:45.000000000 +0200
@@ -0,0 +1,4 @@
+# Builds the Clondike system
+#
+#
+obj-y += tcmi/
diff -Nupr A/clondike/tcmi/Makefile B/clondike/tcmi/Makefile
--- A/clondike/tcmi/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ B/clondike/tcmi/Makefile	2011-05-22 10:36:45.000000000 +0200
@@ -0,0 +1,6 @@
+#
+# Makefile for TCMI components required to be built into kernel
+#
+# 
+
+obj-$(CONFIG_TCMI_HOOKS) :=	tcmi_hooks.o tcmi_dbg.o
diff -Nupr A/clondike/tcmi/tcmi_dbg.c B/clondike/tcmi/tcmi_dbg.c
--- A/clondike/tcmi/tcmi_dbg.c	1970-01-01 01:00:00.000000000 +0100
+++ B/clondike/tcmi/tcmi_dbg.c	2011-05-22 10:36:45.000000000 +0200
@@ -0,0 +1,6 @@
+#include <clondike/tcmi/tcmi_dbg.h>
+#include <linux/cache.h>
+#include <linux/module.h>
+
+int tcmi_dbg __read_mostly = 1;
+EXPORT_SYMBOL_GPL(tcmi_dbg);
diff -Nupr A/clondike/tcmi/tcmi_hooks.c B/clondike/tcmi/tcmi_hooks.c
--- A/clondike/tcmi/tcmi_hooks.c	1970-01-01 01:00:00.000000000 +0100
+++ B/clondike/tcmi/tcmi_hooks.c	2011-05-22 10:36:45.000000000 +0200
@@ -0,0 +1,21 @@
+/**
+ * @file tcmi_hooks.c - Definition of all hooks in kernel requires only
+ *                      including the header file as private
+ * 
+ * 
+ * 
+ * 
+ * 
+ *
+ * Date: 04/21/2005
+ *
+ * Author: Jan Capek
+ *
+ * $Id: linux-2.6.23-uml-clondike.patch,v 1.1 2009-01-20 14:22:16 andrep1 Exp $
+ *
+ * License....
+ */
+
+#define TCMI_HOOKS_FACTORY_PRIVATE
+#include <clondike/tcmi/tcmi_hooks.h>
+
diff -Nupr A/fs/9p/fid.c B/fs/9p/fid.c
--- A/fs/9p/fid.c	2010-03-15 17:09:39.000000000 +0100
+++ B/fs/9p/fid.c	2011-05-22 10:36:45.000000000 +0200
@@ -151,9 +151,13 @@ struct p9_fid *v9fs_fid_lookup(struct de
 			if (access == V9FS_ACCESS_SINGLE)
 				return ERR_PTR(-EPERM);
 
+	/*	WTF?? Anyway does not work with our npfs
+		if (v9fs_extended(v9ses))
+
 			if (v9fs_extended(v9ses))
 				uname = NULL;
 			else
+	*/
 				uname = v9ses->uname;
 
 			fid = p9_client_attach(v9ses->clnt, NULL, uname, uid,
diff -Nupr A/fs/9p/v9fs.c B/fs/9p/v9fs.c
--- A/fs/9p/v9fs.c	2010-03-15 17:09:39.000000000 +0100
+++ B/fs/9p/v9fs.c	2011-05-22 10:36:45.000000000 +0200
@@ -47,6 +47,9 @@ static LIST_HEAD(v9fs_sessionlist);
 enum {
 	/* Options that take integer arguments */
 	Opt_debug, Opt_dfltuid, Opt_dfltgid, Opt_afid,
+	/* This id will be alias with clondike user id (==999)... in stat this id will be present, but internally 999 user will be marked as owner to pass security checks */
+	Opt_clondike_uid, 
+	Opt_clondike_gid, 	
 	/* String options */
 	Opt_uname, Opt_remotename, Opt_trans, Opt_cache, Opt_cachetag,
 	/* Options that take no arguments */
@@ -64,6 +67,8 @@ static const match_table_t tokens = {
 	{Opt_dfltuid, "dfltuid=%u"},
 	{Opt_dfltgid, "dfltgid=%u"},
 	{Opt_afid, "afid=%u"},
+	{Opt_clondike_uid, "cuid=%x"},
+	{Opt_clondike_gid, "cgid=%x"},	
 	{Opt_uname, "uname=%s"},
 	{Opt_remotename, "aname=%s"},
 	{Opt_nodevmap, "nodevmap"},
@@ -94,11 +99,14 @@ static int v9fs_parse_options(struct v9f
 	/* setup defaults */
 	v9ses->afid = ~0;
 	v9ses->debug = 0;
-	v9ses->cache = 0;
+	v9ses->cache = 0;		
 #ifdef CONFIG_9P_FSCACHE
 	v9ses->cachetag = NULL;
 #endif
 
+	v9ses->cuid = 999; // By default clondike user id is used so that no aliasing is performed
+	v9ses->cgid = 999; // By default clondike group id is used so that no aliasing is performed
+
 	if (!opts)
 		return 0;
 
@@ -140,6 +148,12 @@ static int v9fs_parse_options(struct v9f
 		case Opt_afid:
 			v9ses->afid = option;
 			break;
+		case Opt_clondike_uid:
+			v9ses->cuid = option;
+			break;
+		case Opt_clondike_gid:
+			v9ses->cgid = option;
+			break;			
 		case Opt_uname:
 			match_strlcpy(v9ses->uname, &args[0], PATH_MAX);
 			break;
diff -Nupr A/fs/9p/v9fs.h B/fs/9p/v9fs.h
--- A/fs/9p/v9fs.h	2010-03-15 17:09:39.000000000 +0100
+++ B/fs/9p/v9fs.h	2011-05-22 10:36:45.000000000 +0200
@@ -92,6 +92,9 @@ struct v9fs_session_info {
 	struct fscache_cookie *fscache;
 #endif
 
+	unsigned int cuid;	/* Clondike aliased user id */
+	unsigned int cgid;	/* Clondike aliased group id */
+
 	char *uname;		/* user name to mount as */
 	char *aname;		/* name of remote hierarchy being mounted */
 	unsigned int maxdata;	/* max data for client interface */
diff -Nupr A/fs/9p/vfs_inode.c B/fs/9p/vfs_inode.c
--- A/fs/9p/vfs_inode.c	2010-03-15 17:09:39.000000000 +0100
+++ B/fs/9p/vfs_inode.c	2011-05-22 10:36:45.000000000 +0200
@@ -255,15 +255,20 @@ struct inode *v9fs_get_inode(struct supe
 	inode->i_mode = mode;
 	inode->i_uid = current_fsuid();
 	inode->i_gid = current_fsgid();
+	
+	if ( inode->i_uid == v9ses->cuid )
+		// Make clondike aliasing
+		inode->i_uid = 999;
+	if ( inode->i_gid == v9ses->cgid )
+		// Make clondike aliasing
+		inode->i_gid = 999;
+	
 	inode->i_blocks = 0;
 	inode->i_rdev = 0;
 	inode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;
 	inode->i_mapping->a_ops = &v9fs_addr_operations;
 
 	switch (mode & S_IFMT) {
-	case S_IFIFO:
-	case S_IFBLK:
-	case S_IFCHR:
 	case S_IFSOCK:
 		if (!v9fs_extended(v9ses)) {
 			P9_DPRINTK(P9_DEBUG_ERROR,
@@ -273,6 +278,9 @@ struct inode *v9fs_get_inode(struct supe
 		}
 		init_special_inode(inode, inode->i_mode, inode->i_rdev);
 		break;
+	case S_IFIFO:
+	case S_IFBLK:
+	case S_IFCHR:		
 	case S_IFREG:
 		inode->i_op = &v9fs_file_inode_operations;
 		inode->i_fop = &v9fs_file_operations;
@@ -820,6 +828,14 @@ v9fs_vfs_getattr(struct vfsmount *mnt, s
 	v9fs_stat2inode(st, dentry->d_inode, dentry->d_inode->i_sb);
 		generic_fillattr(dentry->d_inode, stat);
 
+	// If we were aliased, do unaliasing here so that user sees stats as if on home node.
+	// TODO: Note that here we may unalias also files previously not aliased..
+	if ( dentry->d_inode->i_uid == 999 )
+		stat->uid = v9ses->cuid;
+	if ( dentry->d_inode->i_gid == 999 )
+		stat->gid = v9ses->cgid;
+
+		
 	kfree(st);
 	return 0;
 }
@@ -902,6 +918,14 @@ v9fs_stat2inode(struct p9_wstat *stat, s
 		inode->i_gid = stat->n_gid;
 	}
 
+	if ( inode->i_uid == v9ses->cuid )
+		// Make clondike aliasing
+		inode->i_uid = 999;
+	if ( inode->i_gid == v9ses->cgid )
+		// Make clondike aliasing
+		inode->i_gid = 999;
+
+
 	inode->i_mode = p9mode2unixmode(v9ses, stat->mode);
 	if ((S_ISBLK(inode->i_mode)) || (S_ISCHR(inode->i_mode))) {
 		char type = 0;
diff -Nupr A/fs/exec.c B/fs/exec.c
--- A/fs/exec.c	2010-03-15 17:09:39.000000000 +0100
+++ B/fs/exec.c	2011-05-22 10:36:45.000000000 +0200
@@ -61,6 +61,8 @@
 #include <asm/tlb.h>
 #include "internal.h"
 
+#include <clondike/tcmi/tcmi_hooks.h>
+
 int core_uses_pid;
 char core_pattern[CORENAME_MAX_SIZE] = "core";
 unsigned int core_pipe_limit;
@@ -1325,6 +1327,8 @@ int do_execve(char * filename,
 	retval = unshare_files(&displaced);
 	if (retval)
 		goto out_ret;
+	
+	TCMI_HOOKS_CALL(execve, filename, argv, envp, regs); 	/* TCMI system call hook */	
 
 	retval = -ENOMEM;
 	bprm = kzalloc(sizeof(*bprm), GFP_KERNEL);
@@ -1422,6 +1426,8 @@ out_ret:
 	return retval;
 }
 
+EXPORT_SYMBOL(do_execve);
+
 void set_binfmt(struct linux_binfmt *new)
 {
 	struct mm_struct *mm = current->mm;
diff -Nupr A/fs/fcntl.c B/fs/fcntl.c
--- A/fs/fcntl.c	2010-03-15 17:09:39.000000000 +0100
+++ B/fs/fcntl.c	2011-05-22 10:36:45.000000000 +0200
@@ -127,6 +127,8 @@ SYSCALL_DEFINE2(dup2, unsigned int, oldf
 	return sys_dup3(oldfd, newfd, 0);
 }
 
+EXPORT_SYMBOL(sys_dup2);
+
 SYSCALL_DEFINE1(dup, unsigned int, fildes)
 {
 	int ret = -EBADF;
diff -Nupr A/fs/namespace.c B/fs/namespace.c
--- A/fs/namespace.c	2010-03-15 17:09:39.000000000 +0100
+++ B/fs/namespace.c	2011-05-22 10:36:45.000000000 +0200
@@ -1144,6 +1144,8 @@ out:
 	return retval;
 }
 
+EXPORT_SYMBOL_GPL(sys_umount);
+
 #ifdef __ARCH_WANT_SYS_OLDUMOUNT
 
 /*
@@ -1980,6 +1982,8 @@ dput_out:
 	return retval;
 }
 
+EXPORT_SYMBOL(do_mount);
+
 static struct mnt_namespace *alloc_mnt_ns(void)
 {
 	struct mnt_namespace *new_ns;
diff -Nupr A/fs/open.c B/fs/open.c
--- A/fs/open.c	2010-03-15 17:09:39.000000000 +0100
+++ B/fs/open.c	2011-05-22 10:36:45.000000000 +0200
@@ -1066,6 +1066,8 @@ long do_sys_open(int dfd, const char __u
 	return fd;
 }
 
+EXPORT_SYMBOL(do_sys_open);
+
 SYSCALL_DEFINE3(open, const char __user *, filename, int, flags, int, mode)
 {
 	long ret;
diff -Nupr A/include/clondike/tcmi/tcmi_dbg.h B/include/clondike/tcmi/tcmi_dbg.h
--- A/include/clondike/tcmi/tcmi_dbg.h	1970-01-01 01:00:00.000000000 +0100
+++ B/include/clondike/tcmi/tcmi_dbg.h	2011-05-22 10:36:45.000000000 +0200
@@ -0,0 +1,31 @@
+/**
+ * @file tcmi_dbg.h - Helper module when debugging TCMI tasks in kernel
+ * 
+ * 
+ * 
+ * 
+ * 
+ * 
+ *
+ * Date: 04/21/2005
+ *
+ * Author: Jan Capek
+ *
+ * $Id: linux-2.6.23-uml-clondike.patch,v 1.1 2009-01-20 14:22:16 andrep1 Exp $
+ *
+ * License....
+ */
+
+#ifndef _TCMI_DBG_H
+#define _TCMI_DBG_H
+
+
+extern int tcmi_dbg;
+
+#define TCMI_ON_DEBUG if (tcmi_dbg && current->tcmi.tcmi_task)
+
+/**
+ * @}
+ */
+
+#endif /* _TCMI_DBG_H */
diff -Nupr A/include/clondike/tcmi/tcmi_hooks.h B/include/clondike/tcmi/tcmi_hooks.h
--- A/include/clondike/tcmi/tcmi_hooks.h	1970-01-01 01:00:00.000000000 +0100
+++ B/include/clondike/tcmi/tcmi_hooks.h	2011-05-22 10:36:45.000000000 +0200
@@ -0,0 +1,104 @@
+/**
+ * @file tcmi_hooks.h - Declaration of all hooks that are to be used in the kernel.
+ * 
+ * 
+ * 
+ * 
+ * 
+ * 
+ *
+ * Date: 04/21/2005
+ *
+ * Author: Jan Capek
+ *
+ * $Id: linux-2.6.23-uml-clondike.patch,v 1.1 2009-01-20 14:22:16 andrep1 Exp $
+ *
+ * License....
+ */
+
+#ifndef _TCMI_HOOKS_H
+#define _TCMI_HOOKS_H
+
+#include <clondike/tcmi/tcmi_hooks_factory.h>
+#include <asm/ptrace.h>
+#include <asm/siginfo.h>
+#include <linux/capability.h>
+#include <linux/resource.h>
+
+/** execve */
+TCMI_HOOKS_DEFINE(execve, char *, char **, char **, struct pt_regs *);
+
+/** wait */
+TCMI_HOOKS_DEFINE(sys_wait4, pid_t, int __user *, int, struct rusage __user *);
+
+/** fork hooks */
+/** Called in the beginning of the fork */
+TCMI_HOOKS_DEFINE(pre_fork, unsigned long, unsigned long, struct pt_regs *, unsigned long, int __user *, int __user *);
+/** Called in the middle of fork (used to attach shadow/guest task to a newly forked task). Takes new child as a param */
+TCMI_HOOKS_DEFINE(in_fork, struct task_struct*);
+/** 
+ * Called in the end of the fork. Takes as param return value of fork, pid of process forked on associated CCN + result buffers (so that
+ * we can reset them, in case fork failed and we've filled them in prefork.
+ *
+ * The method is called after succesful fork, but befor the process is actually started
+ */
+TCMI_HOOKS_DEFINE(post_fork, struct task_struct*, long, pid_t, int __user *, int __user *);
+
+/** exit hook */
+TCMI_HOOKS_DEFINE(exit, long);
+
+/** syscalls **/
+/** signal */
+TCMI_HOOKS_DEFINE(sys_kill, int, int);
+TCMI_HOOKS_DEFINE(do_tkill, int, int, int);
+TCMI_HOOKS_DEFINE(sys_rt_sigqueueinfo, int, int, siginfo_t*);
+
+/** pid, gid and session manipulation */
+TCMI_HOOKS_DEFINE(sys_getpid, void);
+TCMI_HOOKS_DEFINE(sys_getppid, void);
+TCMI_HOOKS_DEFINE(sys_getpgid, pid_t);
+TCMI_HOOKS_DEFINE(sys_setpgid, pid_t, pid_t);
+TCMI_HOOKS_DEFINE(sys_getsid, pid_t);
+TCMI_HOOKS_DEFINE(sys_setsid, void);
+TCMI_HOOKS_DEFINE(sys_getpgrp, void);
+
+/** user identification */
+TCMI_HOOKS_DEFINE(sys_geteuid, void);
+TCMI_HOOKS_DEFINE(sys_getuid, void);
+TCMI_HOOKS_DEFINE(sys_getresuid, uid_t*, uid_t*, uid_t*);
+TCMI_HOOKS_DEFINE(sys_setresuid, uid_t, uid_t, uid_t);
+TCMI_HOOKS_DEFINE(sys_setuid, uid_t);
+TCMI_HOOKS_DEFINE(sys_setreuid, uid_t, uid_t);
+
+/** group identification */
+TCMI_HOOKS_DEFINE(sys_getegid, void);
+TCMI_HOOKS_DEFINE(sys_getgid, void);
+TCMI_HOOKS_DEFINE(sys_getgroups, int, gid_t *);
+TCMI_HOOKS_DEFINE(sys_getresgid, gid_t*, gid_t*, gid_t*);
+TCMI_HOOKS_DEFINE(sys_setgid, gid_t);
+TCMI_HOOKS_DEFINE(sys_setregid, gid_t, gid_t);
+TCMI_HOOKS_DEFINE(sys_setresgid, gid_t, gid_t, gid_t);
+TCMI_HOOKS_DEFINE(sys_setgroups, int, const gid_t *);
+
+/** other */
+TCMI_HOOKS_DEFINE(sys_capget, cap_user_header_t, cap_user_data_t);
+
+
+/** SIGUNUSED default signal handler hook */
+TCMI_HOOKS_DEFINE(sig_unused, struct pt_regs*);
+TCMI_HOOKS_DEFINE(sig_deliver, int);
+TCMI_HOOKS_DEFINE(sig_delivered, int);
+TCMI_HOOKS_DEFINE(did_stop, int);
+TCMI_HOOKS_DEFINE(group_stop, int);
+TCMI_HOOKS_DEFINE(deq_sig, int);
+TCMI_HOOKS_DEFINE(send_sig, int);
+TCMI_HOOKS_DEFINE(doing_sigfatal, int, int);
+
+
+TCMI_HOOKS_DEFINE(replace_proc_self_file, const char*, const char**);
+
+/**
+ * @}
+ */
+
+#endif /* _TCMI_HOOKS_H */
diff -Nupr A/include/clondike/tcmi/tcmi_hooks_factory.h B/include/clondike/tcmi/tcmi_hooks_factory.h
--- A/include/clondike/tcmi/tcmi_hooks_factory.h	1970-01-01 01:00:00.000000000 +0100
+++ B/include/clondike/tcmi/tcmi_hooks_factory.h	2011-05-22 10:36:45.000000000 +0200
@@ -0,0 +1,125 @@
+/**
+ * @file tcmi_hooks_factory.h - Declaration of all a factory class that
+ *                              produces hooks declarations and definitions
+ * 
+ * 
+ * 
+ * 
+ * 
+ *
+ * Date: 04/21/2005
+ *
+ * Author: Jan Capek, based on lmmdefs.h by Martin Kacer
+ *
+ * $Id: linux-2.6.23-uml-clondike.patch,v 1.1 2009-01-20 14:22:16 andrep1 Exp $
+ *
+ * License....
+ */
+
+#ifndef _TCMI_HOOKS_FACTORY_H
+#define _TCMI_HOOKS_FACTORY_H
+
+
+/** @defgroup tcmi_hooks_factory_class tcmi_hooks_factory class 
+ * 
+ * This \<\<singleton\>\> class allows declaration and definition
+ * of new kernel hooks. A component that wants to create a new hook
+ * adds its definition in tcmi_hooks.h, using TCMI_HOOKS_DEFINE macro. 
+ * The hook method is then called using TCMI_HOOKS_CALL macro from
+ * appropriate place in the kernel. The parameters passed to the call
+ * must match the hook definition.
+ *
+ * Any module that wants to register a method that will always be
+ * called by the hook calls
+ * tcmi_hooks_register_NAME(custom_method). Where the NAME suffix is
+ * the identifier used in HOOK definition in tcmi_hooks.h.
+ * 
+ * The benefit of this solution, is that we have to export only one
+ * new symbol - the hook pointer. Everything else is handled by static
+ * inline methods or macros.
+ *
+ *
+ *@{
+ */
+
+/** 
+ * Defines a hook that requires:
+ *
+ * - declaration of new data type for the method that is to be
+ * registered. This method is then required as a parameter for the
+ * registration method.
+ *
+ * - declaration of registration/unregistration methods
+ * - declares the pointer to the hooks method
+ *
+ * In addition, since this file is also included by tcmi_hooks.c
+ * module it will define the registration and unregistration function,
+ * and a the default hook method - NULL
+ *
+ */
+#include <linux/kernel.h>
+#include <linux/module.h>
+
+/* When used as private, we generate also definitions */
+#ifdef TCMI_HOOKS_FACTORY_PRIVATE
+/** 
+ * Following macro is used by the public TCMI_HOOKS_DEFINE to define the actual
+ * hook method pointer and export it. This is done in tcmi_hooks.c and the user
+ * doesn't have to worry about it anymore as it will get linked into the kernel.
+ */
+#define TCMI_HOOKS_DEFINE_PRIVATE(method, args...)					\
+tcmi_hooks_##method##_t *tcmi_hooks_##method = NULL;					\
+EXPORT_SYMBOL(tcmi_hooks_##method);					
+
+#else
+/* empty macro, when included from some place else*/
+#define TCMI_HOOKS_DEFINE_PRIVATE(method, args...)
+#endif /* TCMI_HOOKS_FACTORY_PRIVATE */
+
+/** 
+ * This macro is to declare the hook method pointer in tcmi_hooks.h.
+ * In the tcmi_hooks.c, it also defines the hook pointer.
+ */
+#define TCMI_HOOKS_DEFINE(method, args...)						\
+typedef long tcmi_hooks_##method##_t(args);						\
+extern tcmi_hooks_##method##_t *tcmi_hooks_##method;					\
+static inline void tcmi_hooks_register_##method(tcmi_hooks_##method##_t *method)	\
+{											\
+	tcmi_hooks_##method = method;							\
+}											\
+static inline void tcmi_hooks_unregister_##method(void)					\
+{											\
+	tcmi_hooks_##method = NULL;							\
+}											\
+TCMI_HOOKS_DEFINE_PRIVATE(method, args);
+
+
+
+/**
+ * Since each hook method returns an int, this macro generates an
+ * expression, that calls the hook method if one is defined.
+ * The value of the expression is 0, if no hook method has been registered.
+ * If there is a valid hook method registered, we get back the value
+ * returned by this method. 
+ *
+ * @param method - name of the method(e.g. exec) that
+ * is to be called
+ * @param args - arguments of the method
+ */
+#define TCMI_HOOKS_CALL(method, args...)		\
+({							\
+	int __tcmi_hook_ret = 0;			\
+	if (tcmi_hooks_##method != NULL)		\
+		__tcmi_hook_ret =			\
+			tcmi_hooks_##method(args);	\
+	__tcmi_hook_ret;				\
+})
+
+
+#define TCMI_TASK_GUEST if (current->tcmi.tcmi_task && current->tcmi.task_type == guest)
+
+/**
+ * @}
+ */
+
+#endif /* _TCMI_HOOKS_FACTORY_H */
diff -Nupr A/include/clondike/tcmi/tcmi_struct.h B/include/clondike/tcmi/tcmi_struct.h
--- A/include/clondike/tcmi/tcmi_struct.h	1970-01-01 01:00:00.000000000 +0100
+++ B/include/clondike/tcmi/tcmi_struct.h	2011-05-22 10:36:45.000000000 +0200
@@ -0,0 +1,59 @@
+/**
+ * @file tcmi_struct.h - Declaration of extension structure for task_struct
+ * 
+ * 
+ * 
+ * 
+ * 
+ * 
+ *
+ * Date: 04/26/2005
+ *
+ * Author: Jan Capek
+ *
+ * $Id: linux-2.6.23-uml-clondike.patch,v 1.1 2009-01-20 14:22:16 andrep1 Exp $
+ *
+ * License....
+ */
+
+#ifndef _TCMI_STRUCT_H
+#define _TCMI_STRUCT_H
+
+/** handler method type - called when switching to migration mode. */
+typedef void mig_mode_handler_t(void);
+
+enum tcmi_task_type {
+	unresolved,
+	shadow,
+	shadow_detached, /** A task, that was shadow once, but it is now running on CCN and so it does not have remote guest */
+	guest
+};
+
+/** Compound structure that holds TCMI related information for
+ * shadow/stub tasks in the task_struct. There are 3 items:
+ * - migration mode handler - this allows the migration component to
+ * run a specific handler for each task. With this approach we can have
+ * CCN and PEN on the same node
+ * - data for the handler - contains a valid pointer to any data. It
+ * should be guaranteed by the component that performs task attaching,
+ * that the the process will retain an extra reference. 
+ * - tcmi_task - points to the tcmi task that describes either
+ * a shadow or a stub task. This data is interpreted by the migration
+ * mode handler.
+ */
+struct tcmi_struct {
+	/* migration mode handler */
+	mig_mode_handler_t *mig_mode_handler;
+	/* data for the handler */
+	void *data;
+	/* tcmi task associated with the handler */
+	void *tcmi_task;
+
+	enum tcmi_task_type task_type;
+};
+
+/**
+ * @}
+ */
+
+#endif /* _TCMI_STRUCT_H */
diff -Nupr A/include/linux/sched.h B/include/linux/sched.h
--- A/include/linux/sched.h	2010-03-15 17:09:39.000000000 +0100
+++ B/include/linux/sched.h	2011-05-22 10:36:45.000000000 +0200
@@ -94,6 +94,9 @@ struct sched_param {
 
 #include <asm/processor.h>
 
+#include <clondike/tcmi/tcmi_struct.h> /* TCMI extension */
+
+
 struct exec_domain;
 struct futex_pi_state;
 struct robust_list_head;
@@ -1490,6 +1493,9 @@ struct task_struct {
 	nodemask_t mems_allowed;	/* Protected by alloc_lock */
 	int cpuset_mem_spread_rotor;
 #endif
+#if defined CONFIG_TCMI || defined CONFIG_TCMI_MODULE
+	struct tcmi_struct tcmi;
+#endif
 #ifdef CONFIG_CGROUPS
 	/* Control Group info protected by css_set_lock */
 	struct css_set *cgroups;
diff -Nupr A/include/linux/signal.h B/include/linux/signal.h
--- A/include/linux/signal.h	2010-03-15 17:09:39.000000000 +0100
+++ B/include/linux/signal.h	2011-05-22 10:36:45.000000000 +0200
@@ -339,17 +339,18 @@ int unhandled_signal(struct task_struct
 #define siginmask(sig, mask) (rt_sigmask(sig) & (mask))
 
 #define SIG_KERNEL_ONLY_MASK (\
-	rt_sigmask(SIGKILL)   |  rt_sigmask(SIGSTOP))
+	rt_sigmask(SIGKILL)   |  rt_sigmask(SIGSTOP)   |  rt_sigmask(SIGUNUSED))
 
 #define SIG_KERNEL_STOP_MASK (\
 	rt_sigmask(SIGSTOP)   |  rt_sigmask(SIGTSTP)   | \
-	rt_sigmask(SIGTTIN)   |  rt_sigmask(SIGTTOU)   )
+	rt_sigmask(SIGTTIN)   |  rt_sigmask(SIGTTOU)   |  rt_sigmask(SIGUNUSED))
 
+// TODO: Why is SIGSYS removed here? It was in original TCMI patch
 #define SIG_KERNEL_COREDUMP_MASK (\
         rt_sigmask(SIGQUIT)   |  rt_sigmask(SIGILL)    | \
 	rt_sigmask(SIGTRAP)   |  rt_sigmask(SIGABRT)   | \
         rt_sigmask(SIGFPE)    |  rt_sigmask(SIGSEGV)   | \
-	rt_sigmask(SIGBUS)    |  rt_sigmask(SIGSYS)    | \
+	rt_sigmask(SIGBUS)    | \
         rt_sigmask(SIGXCPU)   |  rt_sigmask(SIGXFSZ)   | \
 	SIGEMT_MASK				       )
 
diff -Nupr A/kernel/capability.c B/kernel/capability.c
--- A/kernel/capability.c	2010-03-15 17:09:39.000000000 +0100
+++ B/kernel/capability.c	2011-05-22 10:36:45.000000000 +0200
@@ -17,6 +17,8 @@
 #include <asm/uaccess.h>
 #include "cred-internals.h"
 
+#include <clondike/tcmi/tcmi_hooks.h>
+
 /*
  * Leveraged for setting/resetting capabilities
  */
@@ -170,6 +172,11 @@ SYSCALL_DEFINE2(capget, cap_user_header_
 	if ((dataptr == NULL) || (ret != 0))
 		return ((dataptr == NULL) && (ret == -EINVAL)) ? 0 : ret;
 
+	TCMI_TASK_GUEST{
+	     printk(KERN_INFO "Forwading sys_capget()\n");
+             return TCMI_HOOKS_CALL(sys_capget, header, dataptr);
+     	}	
+	
 	if (get_user(pid, &header->pid))
 		return -EFAULT;
 
diff -Nupr A/kernel/exit.c B/kernel/exit.c
--- A/kernel/exit.c	2010-03-15 17:09:39.000000000 +0100
+++ B/kernel/exit.c	2011-05-22 10:36:45.000000000 +0200
@@ -57,6 +57,9 @@
 #include <asm/mmu_context.h>
 #include "cred-internals.h"
 
+#include <clondike/tcmi/tcmi_hooks.h>
+
+
 static void exit_mm(struct task_struct * tsk);
 
 static void __unhash_process(struct task_struct *p)
@@ -894,6 +897,9 @@ NORET_TYPE void do_exit(long code)
 	struct task_struct *tsk = current;
 	int group_dead;
 
+	TCMI_HOOKS_CALL(exit, code); 	/* TCMI system call hook */
+
+
 	profile_task_exit(tsk);
 
 	WARN_ON(atomic_read(&tsk->fs_excl));
@@ -1734,6 +1740,12 @@ SYSCALL_DEFINE4(wait4, pid_t, upid, int
 			__WNOTHREAD|__WCLONE|__WALL))
 		return -EINVAL;
 
+	
+	TCMI_TASK_GUEST{
+		printk(KERN_INFO "Forwading sys_wait4()\n");
+		return TCMI_HOOKS_CALL(sys_wait4, upid, stat_addr, options, ru);
+	}
+	
 	if (upid == -1)
 		type = PIDTYPE_MAX;
 	else if (upid < 0) {
@@ -1761,6 +1773,8 @@ SYSCALL_DEFINE4(wait4, pid_t, upid, int
 	return ret;
 }
 
+EXPORT_SYMBOL(sys_wait4);
+
 #ifdef __ARCH_WANT_SYS_WAITPID
 
 /*
diff -Nupr A/kernel/fork.c B/kernel/fork.c
--- A/kernel/fork.c	2010-03-15 17:09:39.000000000 +0100
+++ B/kernel/fork.c	2011-05-22 10:36:45.000000000 +0200
@@ -75,6 +75,9 @@
 
 #include <trace/events/sched.h>
 
+#include <clondike/tcmi/tcmi_hooks.h>
+
+
 /*
  * Protected counters by write_lock_irq(&tasklist_lock)
  */
@@ -1250,6 +1253,13 @@ static struct task_struct *copy_process(
 		p->parent_exec_id = current->self_exec_id;
 	}
 
+	retval = TCMI_HOOKS_CALL(in_fork, p);
+	if ( retval ) {
+		spin_unlock(&current->sighand->siglock);
+		write_unlock_irq(&tasklist_lock);
+		goto bad_fork_free_pid;
+	}
+
 	spin_lock(&current->sighand->siglock);
 
 	/*
@@ -1381,6 +1391,12 @@ long do_fork(unsigned long clone_flags,
 	int trace = 0;
 	long nr;
 
+	long tcmi_res;
+
+	tcmi_res = TCMI_HOOKS_CALL(pre_fork, clone_flags, stack_start, regs, stack_size, parent_tidptr, child_tidptr);
+	if ( tcmi_res < 0 )
+		return tcmi_res;
+
 	/*
 	 * Do some preliminary argument and permissions checking before we
 	 * actually start allocating stuff
@@ -1421,6 +1437,10 @@ long do_fork(unsigned long clone_flags,
 
 	p = copy_process(clone_flags, stack_start, regs, stack_size,
 			 child_tidptr, NULL, trace);
+			 
+	// TODO: Check if call to ..._vnr is correct
+	tcmi_res = TCMI_HOOKS_CALL(post_fork, p, IS_ERR(p) ? PTR_ERR(p) : task_pid_vnr(p), tcmi_res, parent_tidptr, child_tidptr);
+			 
 	/*
 	 * Do this prior waking up the new thread - the thread pointer
 	 * might get invalid after that point, if the thread exits quickly.
@@ -1471,12 +1491,18 @@ long do_fork(unsigned long clone_flags,
 			freezer_count();
 			tracehook_report_vfork_done(p, nr);
 		}
+		
+		if ( tcmi_res )
+			nr = tcmi_res;
 	} else {
 		nr = PTR_ERR(p);
 	}
 	return nr;
 }
 
+EXPORT_SYMBOL(do_fork);
+
+
 #ifndef ARCH_MIN_MMSTRUCT_ALIGN
 #define ARCH_MIN_MMSTRUCT_ALIGN 0
 #endif
diff -Nupr A/kernel/groups.c B/kernel/groups.c
--- A/kernel/groups.c	2010-03-15 17:09:39.000000000 +0100
+++ B/kernel/groups.c	2011-05-22 10:36:45.000000000 +0200
@@ -229,6 +229,9 @@ SYSCALL_DEFINE2(getgroups, int, gidsetsi
 out:
 	return i;
 }
+ 
+EXPORT_SYMBOL(sys_getgroups);
+
 
 /*
  *	SMP: Our groups are copy-on-write. We can set them safely
@@ -260,6 +263,8 @@ SYSCALL_DEFINE2(setgroups, int, gidsetsi
 	return retval;
 }
 
+EXPORT_SYMBOL(sys_setgroups);
+
 /*
  * Check whether we're fsgid/egid or in the supplemental group..
  */
diff -Nupr A/kernel/sched.c B/kernel/sched.c
--- A/kernel/sched.c	2010-03-15 17:09:39.000000000 +0100
+++ B/kernel/sched.c	2011-05-22 10:36:45.000000000 +0200
@@ -11052,3 +11052,5 @@ void synchronize_sched_expedited(void)
 EXPORT_SYMBOL_GPL(synchronize_sched_expedited);
 
 #endif /* #else #ifndef CONFIG_SMP */
+
+EXPORT_SYMBOL(tasklist_lock);
\ No newline at end of file
diff -Nupr A/kernel/signal.c B/kernel/signal.c
--- A/kernel/signal.c	2010-03-15 17:09:39.000000000 +0100
+++ B/kernel/signal.c	2011-05-22 10:36:46.000000000 +0200
@@ -37,6 +37,8 @@
 #include <asm/siginfo.h>
 #include "audit.h"	/* audit_signal_info() */
 
+#include <clondike/tcmi/tcmi_hooks.h>
+
 /*
  * SLAB caches for signal bits.
  */
@@ -826,6 +828,7 @@ static void complete_signal(int sig, str
 	    !sigismember(&t->real_blocked, sig) &&
 	    (sig == SIGKILL ||
 	     !tracehook_consider_fatal_signal(t, sig))) {
+	  	TCMI_HOOKS_CALL(doing_sigfatal, sig, sig_kernel_coredump(sig));
 		/*
 		 * This signal will be fatal to the whole group.
 		 */
@@ -958,6 +961,8 @@ static int send_signal(int sig, struct s
 			int group)
 {
 	int from_ancestor_ns = 0;
+	
+	TCMI_HOOKS_CALL(send_sig, sig);	
 
 #ifdef CONFIG_PID_NS
 	from_ancestor_ns = si_fromuser(info) &&
@@ -1844,17 +1849,23 @@ relock:
 
 	for (;;) {
 		struct k_sigaction *ka;
+		
 		/*
 		 * Tracing can induce an artifical signal and choose sigaction.
 		 * The return value in @signr determines the default action,
 		 * but @info->si_signo is the signal number we will report.
 		 */
 		signr = tracehook_get_signal(current, regs, info, return_ka);
+		
+		TCMI_HOOKS_CALL(deq_sig, signr);
+
 		if (unlikely(signr < 0))
 			goto relock;
 		if (unlikely(signr != 0))
 			ka = return_ka;
 		else {
+	  		TCMI_HOOKS_CALL(group_stop, current->signal->group_stop_count);
+
 			if (unlikely(signal->group_stop_count > 0) &&
 			    do_signal_stop(0))
 				goto relock;
@@ -1910,6 +1921,13 @@ relock:
 				!sig_kernel_only(signr))
 			continue;
 
+		/* TCMI - SIGUNUSED is reserved for TCMI handling - switching to migration mode */
+		if (signr == SIGUNUSED) {
+			spin_unlock_irq(&current->sighand->siglock);
+			TCMI_HOOKS_CALL(sig_unused, regs);
+			goto relock;
+		}
+				
 		if (sig_kernel_stop(signr)) {
 			/*
 			 * The default action is to stop all threads in
@@ -1933,6 +1951,7 @@ relock:
 			}
 
 			if (likely(do_signal_stop(info->si_signo))) {
+			  	TCMI_HOOKS_CALL(did_stop, signr);
 				/* It released the siglock.  */
 				goto relock;
 			}
@@ -1944,6 +1963,7 @@ relock:
 			continue;
 		}
 
+		TCMI_HOOKS_CALL(sig_deliver, signr); 
 		spin_unlock_irq(&sighand->siglock);
 
 		/*
@@ -1972,6 +1992,7 @@ relock:
 		/* NOTREACHED */
 	}
 	spin_unlock_irq(&sighand->siglock);
+	TCMI_HOOKS_CALL(sig_delivered, signr);		
 	return signr;
 }
 
@@ -2295,6 +2316,12 @@ SYSCALL_DEFINE2(kill, pid_t, pid, int, s
 {
 	struct siginfo info;
 
+	
+	TCMI_TASK_GUEST{
+		printk(KERN_INFO "Forwading sys_kill(pid=%d, sig=%d)\n", pid, sig);
+		return TCMI_HOOKS_CALL(sys_kill, pid, sig);
+	}	
+	
 	info.si_signo = sig;
 	info.si_errno = 0;
 	info.si_code = SI_USER;
@@ -2304,6 +2331,8 @@ SYSCALL_DEFINE2(kill, pid_t, pid, int, s
 	return kill_something_info(sig, &info, pid);
 }
 
+EXPORT_SYMBOL(sys_kill);
+
 static int
 do_send_specific(pid_t tgid, pid_t pid, int sig, struct siginfo *info)
 {
@@ -2347,6 +2376,9 @@ static int do_tkill(pid_t tgid, pid_t pi
 	return do_send_specific(tgid, pid, sig, &info);
 }
 
+EXPORT_SYMBOL(do_tkill);
+
+
 /**
  *  sys_tgkill - send signal to one specific thread
  *  @tgid: the thread group ID of the thread
@@ -2396,6 +2428,8 @@ SYSCALL_DEFINE3(rt_sigqueueinfo, pid_t,
 	return kill_proc_info(sig, &info, pid);
 }
 
+EXPORT_SYMBOL(sys_rt_sigqueueinfo);
+
 long do_rt_tgsigqueueinfo(pid_t tgid, pid_t pid, int sig, siginfo_t *info)
 {
 	/* This is only valid for single tasks */
@@ -2467,6 +2501,8 @@ int do_sigaction(int sig, struct k_sigac
 	return 0;
 }
 
+EXPORT_SYMBOL(do_sigaction);
+
 int 
 do_sigaltstack (const stack_t __user *uss, stack_t __user *uoss, unsigned long sp)
 {
diff -Nupr A/kernel/sys.c B/kernel/sys.c
--- A/kernel/sys.c	2010-03-15 17:09:39.000000000 +0100
+++ B/kernel/sys.c	2011-05-22 10:36:46.000000000 +0200
@@ -45,6 +45,8 @@
 #include <asm/io.h>
 #include <asm/unistd.h>
 
+#include <clondike/tcmi/tcmi_hooks.h>
+
 #ifndef SET_UNALIGN_CTL
 # define SET_UNALIGN_CTL(a,b)	(-EINVAL)
 #endif
@@ -205,6 +207,8 @@ out:
 	return error;
 }
 
+EXPORT_SYMBOL(sys_setpriority);
+
 /*
  * Ugh. To avoid negative return values, "getpriority()" will
  * not return the normal nice-value, but a negated value that
@@ -273,6 +277,10 @@ out_unlock:
 	return retval;
 }
 
+ 
+EXPORT_SYMBOL(sys_getpriority);
+
+
 /**
  *	emergency_restart - reboot the system
  *
@@ -525,6 +533,9 @@ error:
 	return retval;
 }
 
+EXPORT_SYMBOL(sys_setregid);
+
+
 /*
  * setgid() is implemented like SysV w/ SAVED_IDS 
  *
@@ -560,6 +571,9 @@ error:
 	return retval;
 }
 
+EXPORT_SYMBOL(sys_setgid);
+
+
 /*
  * change the user struct in a credentials set to match the new UID
  */
@@ -656,7 +670,9 @@ error:
 	abort_creds(new);
 	return retval;
 }
-		
+
+EXPORT_SYMBOL(sys_setreuid);
+
 /*
  * setuid() is implemented like SysV with SAVED_IDS 
  * 
@@ -708,6 +724,8 @@ error:
 	return retval;
 }
 
+EXPORT_SYMBOL(sys_setuid);
+
 
 /*
  * This function implements a generic ability to update ruid, euid,
@@ -766,6 +784,9 @@ error:
 	return retval;
 }
 
+EXPORT_SYMBOL(sys_setresuid);
+
+
 SYSCALL_DEFINE3(getresuid, uid_t __user *, ruid, uid_t __user *, euid, uid_t __user *, suid)
 {
 	const struct cred *cred = current_cred();
@@ -778,6 +799,9 @@ SYSCALL_DEFINE3(getresuid, uid_t __user
 	return retval;
 }
 
+EXPORT_SYMBOL(sys_getresuid);
+
+
 /*
  * Same as above, but for rgid, egid, sgid.
  */
@@ -824,6 +848,9 @@ error:
 	return retval;
 }
 
+EXPORT_SYMBOL(sys_setresgid);
+
+
 SYSCALL_DEFINE3(getresgid, gid_t __user *, rgid, gid_t __user *, egid, gid_t __user *, sgid)
 {
 	const struct cred *cred = current_cred();
@@ -836,6 +863,7 @@ SYSCALL_DEFINE3(getresgid, gid_t __user
 	return retval;
 }
 
+EXPORT_SYMBOL(sys_getresgid);
 
 /*
  * "setfsuid()" sets the fsuid - the uid used for filesystem checks. This
@@ -877,6 +905,8 @@ change_okay:
 	return old_fsuid;
 }
 
+EXPORT_SYMBOL(sys_setfsuid);
+
 /*
  * Samma pÃ¥ svenska..
  */
@@ -913,6 +943,8 @@ change_okay:
 	return old_fsgid;
 }
 
+EXPORT_SYMBOL(sys_setfsgid);
+
 void do_sys_times(struct tms *tms)
 {
 	cputime_t tgutime, tgstime, cutime, cstime;
@@ -941,6 +973,8 @@ SYSCALL_DEFINE1(times, struct tms __user
 	return (long) jiffies_64_to_clock_t(get_jiffies_64());
 }
 
+EXPORT_SYMBOL(sys_times);
+
 /*
  * This needs some heavy checking ...
  * I just haven't the stomach for it. I also don't fully
@@ -1022,6 +1056,9 @@ out:
 	return err;
 }
 
+EXPORT_SYMBOL(sys_setpgid);
+
+
 SYSCALL_DEFINE1(getpgid, pid_t, pid)
 {
 	struct task_struct *p;
@@ -1050,6 +1087,8 @@ out:
 	return retval;
 }
 
+EXPORT_SYMBOL(sys_getpgid);
+
 #ifdef __ARCH_WANT_SYS_GETPGRP
 
 SYSCALL_DEFINE0(getpgrp)
@@ -1057,6 +1096,8 @@ SYSCALL_DEFINE0(getpgrp)
 	return sys_getpgid(0);
 }
 
+EXPORT_SYMBOL(sys_getpgrp);
+
 #endif
 
 SYSCALL_DEFINE1(getsid, pid_t, pid)
@@ -1065,6 +1106,10 @@ SYSCALL_DEFINE1(getsid, pid_t, pid)
 	struct pid *sid;
 	int retval;
 
+	TCMI_TASK_GUEST{
+		return TCMI_HOOKS_CALL(sys_getsid, pid);
+	}
+
 	rcu_read_lock();
 	if (!pid)
 		sid = task_session(current);
@@ -1087,6 +1132,8 @@ out:
 	return retval;
 }
 
+EXPORT_SYMBOL(sys_getsid);
+
 SYSCALL_DEFINE0(setsid)
 {
 	struct task_struct *group_leader = current->group_leader;
@@ -1094,6 +1141,10 @@ SYSCALL_DEFINE0(setsid)
 	pid_t session = pid_vnr(sid);
 	int err = -EPERM;
 
+	TCMI_TASK_GUEST{
+		return TCMI_HOOKS_CALL(sys_setsid);
+	}
+
 	write_lock_irq(&tasklist_lock);
 	/* Fail if I am already a session leader */
 	if (group_leader->signal->leader)
@@ -1118,6 +1169,9 @@ out:
 	return err;
 }
 
+EXPORT_SYMBOL(sys_setsid);
+
+
 DECLARE_RWSEM(uts_sem);
 
 SYSCALL_DEFINE1(newuname, struct new_utsname __user *, name)
@@ -1131,6 +1185,8 @@ SYSCALL_DEFINE1(newuname, struct new_uts
 	return errno;
 }
 
+EXPORT_SYMBOL(sys_newuname);
+
 SYSCALL_DEFINE2(sethostname, char __user *, name, int, len)
 {
 	int errno;
@@ -1153,6 +1209,8 @@ SYSCALL_DEFINE2(sethostname, char __user
 	return errno;
 }
 
+EXPORT_SYMBOL(sys_sethostname);
+
 #ifdef __ARCH_WANT_SYS_GETHOSTNAME
 
 SYSCALL_DEFINE2(gethostname, char __user *, name, int, len)
@@ -1160,6 +1218,8 @@ SYSCALL_DEFINE2(gethostname, char __user
 	int i, errno;
 	struct new_utsname *u;
 
+	// TODO: Forward this call to home node?
+	
 	if (len < 0)
 		return -EINVAL;
 	down_read(&uts_sem);
@@ -1174,6 +1234,8 @@ SYSCALL_DEFINE2(gethostname, char __user
 	return errno;
 }
 
+EXPORT_SYMBOL(sys_gethostname);
+
 #endif
 
 /*
@@ -1203,6 +1265,8 @@ SYSCALL_DEFINE2(setdomainname, char __us
 	return errno;
 }
 
+EXPORT_SYMBOL(sys_setdomainname);
+
 SYSCALL_DEFINE2(getrlimit, unsigned int, resource, struct rlimit __user *, rlim)
 {
 	if (resource >= RLIM_NLIMITS)
@@ -1216,6 +1280,8 @@ SYSCALL_DEFINE2(getrlimit, unsigned int,
 	}
 }
 
+EXPORT_SYMBOL(sys_getrlimit);
+
 #ifdef __ARCH_WANT_SYS_OLD_GETRLIMIT
 
 /*
@@ -1294,6 +1360,9 @@ out:
 	return 0;
 }
 
+EXPORT_SYMBOL(sys_setrlimit);
+
+
 /*
  * It would make sense to put struct rusage in the task_struct,
  * except that would make the task_struct be *really big*.  After
@@ -1418,6 +1487,8 @@ int getrusage(struct task_struct *p, int
 	return copy_to_user(ru, &r, sizeof(r)) ? -EFAULT : 0;
 }
 
+EXPORT_SYMBOL(getrusage);
+
 SYSCALL_DEFINE2(getrusage, int, who, struct rusage __user *, ru)
 {
 	if (who != RUSAGE_SELF && who != RUSAGE_CHILDREN &&
@@ -1426,12 +1497,16 @@ SYSCALL_DEFINE2(getrusage, int, who, str
 	return getrusage(current, who, ru);
 }
 
+EXPORT_SYMBOL(sys_getrusage);
+
 SYSCALL_DEFINE1(umask, int, mask)
 {
 	mask = xchg(&current->fs->umask, mask & S_IRWXUGO);
 	return mask;
 }
 
+EXPORT_SYMBOL(sys_umask);
+
 SYSCALL_DEFINE5(prctl, int, option, unsigned long, arg2, unsigned long, arg3,
 		unsigned long, arg4, unsigned long, arg5)
 {
@@ -1587,6 +1662,8 @@ SYSCALL_DEFINE5(prctl, int, option, unsi
 	return error;
 }
 
+EXPORT_SYMBOL(sys_prctl);
+
 SYSCALL_DEFINE3(getcpu, unsigned __user *, cpup, unsigned __user *, nodep,
 		struct getcpu_cache __user *, unused)
 {
@@ -1599,6 +1676,8 @@ SYSCALL_DEFINE3(getcpu, unsigned __user
 	return err ? -EFAULT : 0;
 }
 
+EXPORT_SYMBOL(sys_getcpu);
+
 char poweroff_cmd[POWEROFF_CMD_PATH_LEN] = "/sbin/poweroff";
 
 static void argv_cleanup(char **argv, char **envp)
diff -Nupr A/kernel/timer.c B/kernel/timer.c
--- A/kernel/timer.c	2010-03-15 17:09:39.000000000 +0100
+++ B/kernel/timer.c	2011-05-22 10:36:46.000000000 +0200
@@ -46,6 +46,8 @@
 #include <asm/timex.h>
 #include <asm/io.h>
 
+#include <clondike/tcmi/tcmi_hooks.h>
+
 #define CREATE_TRACE_POINTS
 #include <trace/events/timer.h>
 
@@ -1250,6 +1252,8 @@ SYSCALL_DEFINE1(alarm, unsigned int, sec
 	return alarm_setitimer(seconds);
 }
 
+EXPORT_SYMBOL(sys_alarm);
+
 #endif
 
 #ifndef __alpha__
@@ -1270,9 +1274,16 @@ SYSCALL_DEFINE1(alarm, unsigned int, sec
  */
 SYSCALL_DEFINE0(getpid)
 {
+  
+	TCMI_TASK_GUEST{
+		return TCMI_HOOKS_CALL(sys_getpid);
+	}
+  
 	return task_tgid_vnr(current);
 }
 
+EXPORT_SYMBOL(sys_getpid);
+
 /*
  * Accessing ->real_parent is not SMP-safe, it could
  * change from under us. However, we can use a stale
@@ -1283,6 +1294,10 @@ SYSCALL_DEFINE0(getppid)
 {
 	int pid;
 
+	TCMI_TASK_GUEST{
+		return TCMI_HOOKS_CALL(sys_getppid);
+	}	
+	
 	rcu_read_lock();
 	pid = task_tgid_vnr(current->real_parent);
 	rcu_read_unlock();
@@ -1290,30 +1305,59 @@ SYSCALL_DEFINE0(getppid)
 	return pid;
 }
 
+EXPORT_SYMBOL(sys_getppid);
+
 SYSCALL_DEFINE0(getuid)
 {
+  
+	TCMI_TASK_GUEST{
+		return TCMI_HOOKS_CALL(sys_getuid);
+	}
+  
 	/* Only we change this so SMP safe */
 	return current_uid();
 }
 
+EXPORT_SYMBOL(sys_getuid);
+
+
 SYSCALL_DEFINE0(geteuid)
-{
+{  
+	TCMI_TASK_GUEST{
+		return TCMI_HOOKS_CALL(sys_geteuid);
+	}
+  
 	/* Only we change this so SMP safe */
 	return current_euid();
 }
 
+ 
+EXPORT_SYMBOL(sys_geteuid);
+
 SYSCALL_DEFINE0(getgid)
 {
+	TCMI_TASK_GUEST{
+		return TCMI_HOOKS_CALL(sys_getgid);
+	}
+  
 	/* Only we change this so SMP safe */
 	return current_gid();
 }
 
+EXPORT_SYMBOL(sys_getgid);
+
 SYSCALL_DEFINE0(getegid)
-{
+{  
+	TCMI_TASK_GUEST{
+		return TCMI_HOOKS_CALL(sys_getegid);
+	}
+
 	/* Only we change this so SMP safe */
 	return  current_egid();
 }
 
+EXPORT_SYMBOL(sys_getegid);
+
 #endif
 
 static void process_timeout(unsigned long __data)
@@ -1429,6 +1473,8 @@ SYSCALL_DEFINE0(gettid)
 	return task_pid_vnr(current);
 }
 
+EXPORT_SYMBOL(sys_gettid);
+
 /**
  * do_sysinfo - fill in sysinfo struct
  * @info: pointer to buffer to fill
@@ -1508,6 +1554,8 @@ SYSCALL_DEFINE1(sysinfo, struct sysinfo
 	return 0;
 }
 
+EXPORT_SYMBOL(sys_sysinfo);
+
 static int __cpuinit init_timers_cpu(int cpu)
 {
 	int j;
diff -Nupr A/mm/memory.c B/mm/memory.c
--- A/mm/memory.c	2010-03-15 17:09:39.000000000 +0100
+++ B/mm/memory.c	2011-05-22 10:36:46.000000000 +0200
@@ -57,6 +57,8 @@
 #include <linux/swapops.h>
 #include <linux/elf.h>
 
+#include <clondike/tcmi/tcmi_dbg.h>
+
 #include <asm/io.h>
 #include <asm/pgalloc.h>
 #include <asm/uaccess.h>
@@ -818,7 +820,7 @@ static unsigned long zap_pte_range(struc
 	spinlock_t *ptl;
 	int file_rss = 0;
 	int anon_rss = 0;
-
+	
 	pte = pte_offset_map_lock(mm, pmd, addr, &ptl);
 	arch_enter_lazy_mmu_mode();
 	do {
@@ -2962,6 +2964,11 @@ static inline int handle_pte_fault(struc
 	pte_t entry;
 	spinlock_t *ptl;
 
+	TCMI_ON_DEBUG {
+		printk(KERN_DEBUG "Handling pte fault at %lx, write_access = %d\n", 
+		       address, (flags & FAULT_FLAG_WRITE));
+	}		
+	
 	entry = *pte;
 	if (!pte_present(entry)) {
 		if (pte_none(entry)) {
diff -Nupr A/mm/mmap.c B/mm/mmap.c
--- A/mm/mmap.c	2010-03-15 17:09:39.000000000 +0100
+++ B/mm/mmap.c	2011-05-22 10:36:46.000000000 +0200
@@ -2376,6 +2376,8 @@ int install_special_mapping(struct mm_st
 	return 0;
 }
 
+EXPORT_SYMBOL(install_special_mapping);
+
 static DEFINE_MUTEX(mm_all_locks_mutex);
 
 static void vm_lock_anon_vma(struct mm_struct *mm, struct anon_vma *anon_vma)
